(function() { // To limit the scope of the private variables

    var module = dojo.provide('twetailer.golf.Common');

    dojo.require('twetailer.Common');

    /* Set of local variables */
    var _common = twetailer.Common,
        _getLabel,
        _locations = {},
        _demands = {},
        _proposals = {},
        _lastDemand,
        _supportGeolocation;

    module.STATES = _common.STATES;
    module.POINT_OF_VIEWS = _common.POINT_OF_VIEWS;

    /**
     * Initializer
     *
     * @param {String} locale Identifier of the chosen locale.
     * @return {Function} Shortcut on the local function getting localized labels.
     */
    module.init = function(locale) {
        _getLabel = _common.init(locale, 'detectLocationButton');

        // Return the shortcut on domderrien.i18n.LabelExtractor.getFrom()
        return _getLabel;
    };

    /**
     * Helper to generate an ISO formatted date without the timezome
     *
     * @param {Date} date to be formatted.
     * @return ISO representation of the given date.
     */
    module.toISOString = _common.toISOString;

    /**
     * Date formatter
     *
     * @param {String} ISO representation of a Date, as generated by the back-end.
     * @return {String} Simply formatted date.
     */
    module.displayDate = function(serializedDate) {
        try {
            var dateObject = dojo.date.stamp.fromISOString(serializedDate);
            return dojo.date.locale.format(dateObject, {selector: 'date'});
        }
        catch (ex) {
            console.log("displayDate('" + serializedDate + "') -- ex: " + ex.message);
            return "<span class='invalidData' title='" + _getLabel('console', 'error_invalid_date', [serializedDate]) + "'>" + _getLabel('console', 'error_invalid_data') + '</span>';
        }
    };

    /**
     * Date & Time formatter
     *
     * @param {String} ISO representation of a Date, as generated by the back-end.
     * @return {String} Simply formatted date.
     */
    module.displayDateTime = function(serializedDate) {
        try {
            var dateObject = dojo.date.stamp.fromISOString(serializedDate);
            return dojo.date.locale.format(dateObject, {selector: 'dateTime'});
        }
        catch (ex) {
            console.log("displayDateTime('" + serializedDate + "') -- ex: " + ex.message);
            return "<span class='invalidData' title='" + _getLabel('console', 'error_invalid_date', [serializedDate]) + "'>" + _getLabel('console', 'error_invalid_data') + '</span>';
        }
    };

    /**
     * Criteria formatter
     *
     * @param {String[]} criteria List of criteria, as generated by the back-end.
     * @return {String} Serialized criteria list.
     */
    module.displayCriteria = function(criteria) {
        if (!criteria) {
            return '';
        }
        if (dojo.isArray(criteria)) {
            return criteria.join(' ');
        }
        console.log('displayCriteria(' + criteria + ') is not an Array');
        return "<span class='invalidData' title='" + _getLabel('console', 'error_invalid_array') + "'>" + _getLabel('console', 'error_invalid_data') + '</span>';
    };

    var _ccTwitterDecoration = ["<a href='http://twitter.com/", null, "' target='twTwitter'>", null, '</a>'];
    var _ccEmailDecoration = ["<a href='mailto:", null, "'>", null, '</a>'];

    /**
     * CC formatter
     *
     * @param {String[]} ccList List of CC-ed users' identifier, as generated by the back-end.
     * @return {String} Serialized identifier list.
     */
    module.displayCCList = function(ccList) {
        if (!ccList) {
            return '';
        }
        if (dojo.isArray(ccList)) {
            var value = [], cc, ccLinked;
            var limit = ccList.length;
            for (var idx = 0; idx < limit; idx++) {
                cc = ccList[idx];
                ccLinked = cc;
                var decorationRef = _ccEmailDecoration;
                if (cc.charAt(0) == '@') {
                    ccLinked = cc.substring(1);
                    decorationRef = _ccTwitterDecoration;
                }
                else if (cc.indexOf('@') == -1) {
                    decorationRef = _ccTwitterDecoration;
                }
                decorationRef[1] = ccLinked;
                decorationRef[3] = cc;
                value.push(decorationRef.join(''));
            }
            return value.join(', ');
        }
        console.log('displayCC(' + ccList + ') is not an Array');
        return "<span class='invalidData' title='" + _getLabel('console', 'error_invalid_array') + "'>" + _getLabel('console', 'error_invalid_data') + '</span>';
    };

    /**
     * Formatter extracting the number of pull cart from the metadata conveyed with the #golf demand
     *
     * @param {Object} metadata Serialized JSON bag
     * return {Number} The number of pull carts stored in the JSON bag, or 0.
     */
    module.displayPullCartNb = function(metadata) {
        try {
            if (metadata) {
                return dojo.fromJson(metadata).pullCart;
            }
        }
        catch (ex) { alert(ex); }
        return 0;
    }

    /**
     * Formatter extracting the number of golf cart from the metadata conveyed with the #golf demand
     *
     * @param {Object} metadata Serialized JSON bag
     * return {Number} The number of golf carts stored in the JSON bag, or 0.
     */
    module.displayGolfCartNb = function(metadata) {
        try {
            if (metadata) {
                return dojo.fromJson(metadata).golfCart;
            }
        }
        catch (ex) { alert(ex); }
        return 0;
    }

    /**
     * Formatter for the list of attached proposal keys
     *
     * @param {Number[]} proposalKeys List of proposal keys.
     * @param {Number} rowIndex index of the data in the grid, used by the trigger launching the Proposal properties pane.
     * @param {Array} decoration Link definition wrapping a proposal key with:
     *                   ${0}: place holder for the proposalKey
     *                   ${1}: place holder for the rowIndex.
     * @return {String} Formatter list of one link per proposal key, a link opening a dialog with the proposal detail.
     */
    module.displayProposalKeys = function(proposalKeys, rowIndex, decoration) {
        if (!proposalKeys) {
            return '';
        }
        if (dojo.isArray(proposalKeys)) {
            var value = [], pK;
            var limit = proposalKeys.length;
            for (var idx = 0; idx < limit; idx++) {
                pK = proposalKeys[idx];
                value.push(dojo.string.substitute(decoration || '${0}', [pK, rowIndex]));
            }
            return value.join(' ');
        }
        return "<span class='invalidData' title='" + _getLabel('console', 'error_invalid_array') + "'>" + _getLabel('console', 'error_invalid_data') + '</span>';
    };

    /**
     * Helper modifying on the fly the constraints for the postal code field
     *
     * @param {String} countryCode New country code.
     * @param {String} postalCodeFieldId Identifier of the postal code field.
     */
    module.updatePostalCodeFieldConstraints = _common.updatePostalCodeFieldConstraints;

    /**
     * Locale formatter with a lookup in the Location list
     *
     * @param {String[]} locationKey Identifier of the Location to represente.
     * @return {String} Composition of the postal and the country codes in a link to Google Maps.
     */
    module.displayLocale = function(locationKey) {
        if (!locationKey) {
            return '';
        }
        var location = _locations[locationKey];
        if (location) {
            return "<a href='javascript:twetailer.Common.showMap(\"" + location.postalCode + '\",\"' + location.countryCode + "\")'>" + location.postalCode + ' ' + location.countryCode + '</a>';
        }
        return "<span class='invalidData' title='" + _getLabel('console', 'error_invalid_locale') + "'>" + _getLabel('console', 'error_invalid_data') + '</span>';
    };

    /**
     * Get the specified demand from the cache.
     *
     * @param {String} demandKey Identifier of the demand to load.
     * @return {Demand} Identified demand if it exists, <code>null</code> otherwise;.
     */
    module.getCachedDemand = function(demandKey) {
        return _demands[demandKey];
    };

    /**
     * Load the demands modified after the given date from the back-end
     *
     * @param {Date} lastModificationDate (Optional) Date to considered before returning the demands (ISO formatted).
     * @param {String} pointOfView (Optional) operation initiator point of view, default to CONSUMER server-side.
     * @param {String} hashTag (Optional) hash tag used to filter out the demands.
     * @return {dojo.Deferred} Object that callers can use to attach callbacks and errbacks.
     */
    module.loadRemoteDemands = function(lastModificationISODate, pointOfView, hashTag) {
        dijit.byId('demandListOverlay').show();
        var data = {
            pointOfView: pointOfView || _common.POINT_OF_VIEWS.CONSUMER,
            lastModificationDate: lastModificationISODate,
            related: ['Location']
        };
        if (hashTag) {
            data.hashTags = [hashTag];
        }
        var dfd = dojo.xhrGet({
            content: data,
            handleAs: 'json',
            load: function(response, ioArgs) {
                if (response && response.success) {
                    // Deferred callback will process the list
                    _lastDemand = null;
                    var resources = response.resources;
                    var resourceNb = resources ? resources.length : 0;
                    if (0 < resourceNb) {
                        _lastDemand = resources[0];
                        for (var i = 0; i < resourceNb; ++i) {
                            // Add the updated demand into the cache
                            var resource = resources[i];
                            _demands[resource.key] = resource;
                            // Remove the associated and possibly updated proposals from the cache
                            var proposalKeys = resource.proposalKeys;
                            var proposalKeyNb = proposalKeys? proposalKeys.length : 0;
                            for (var j = 0; j < proposalKeyNb; j++) {
                                delete _proposals[proposalKeys[j]];
                            }
                        }
                        if (0 < resourceNb) {
                            // Add the locations to the cache
                            var resource = resources[0];
                            var locations = resource.related ? resource.related.Location : null;
                            var locationNb = locations ? locations.length : 0;
                            for (var k = 0; k < locationNb; k++) {
                                var location = locations[k];
                                _locations[location.key] = location;
                            }
                            delete resource.related;
                        }
                    }
                }
                else {
                    alert(response.message + '\nurl: '+ ioArgs.url);
                }
                dijit.byId('demandListOverlay').hide();
                return response;
            },
            error: function(message, ioArgs) {
                dijit.byId('demandListOverlay').hide();
                _common.handleError(message, ioArgs);
            },
            preventCache: true,
            url: '/API/Demand/'
        });
        return dfd;
    };

    /**
     * Callback processing a list of demands that should replace the current grid content
     *
     * @param {Demand[]} List of demands to insert into the grid.
     * @param {DataGrid} Reference on the grid to fetch.
     */
    module.processDemandList = function(resources, grid) {
        // Prepare the data store
        var demandStore = new dojo.data.ItemFileWriteStore({
            data: { identifier: 'key', items: resources }
        });
        // Fetch the grid with the data
        demandStore.fetch({
            query: {},
            onComplete: function(items, request) {
                if (grid.selection) {
                    grid.selection.clear();
                }
                grid.setStore(demandStore);
            },
            error: function(message, ioArgs) {
                _common.handleError(message, ioArgs);
            },
            sort: [{attribute: 'quantity', descending: true}]
        });
    };

    /**
     * Return the last modified demand.
     *
     * @return {Demand} Identified demand if it exists, <code>null</code> otherwise;.
     */
    module.getLastDemand = function(demandKey) {
        return _lastDemand;
    };

    /**
     * Call the back-end to create or update a Demand with the given attribute
     *
     * @param {Object} data Set of attributes built from the <code>form</code> embedded in the dialog box.
     * @param {Number} demandKey (Optional) demand identifier, picked-up in the given JSON bag if missing.
     * @return {dojo.Deferred} Object that callers can use to attach callbacks and errbacks.
     */
    module.updateRemoteDemand = function(data, demandKey) {
        dijit.byId('demandListOverlay').show();
        demandKey = demandKey || data.key;
        var dfd = (demandKey ? dojo.xhrPut : dojo.xhrPost)({
            headers: { 'content-type': 'application/json; charset=utf-8' },
            postData: dojo.toJson(data),
            putData: dojo.toJson(data),
            handleAs: 'json',
            load: function(response, ioArgs) {
                if (response && response.success) {
                    var demand = response.resource;
                    _demands[demand.key] = demand;
                }
                else {
                    alert(response.message + '\nurl: '+ ioArgs.url);
                }
                dijit.byId('demandListOverlay').hide();
            },
            error: function(message, ioArgs) {
                dijit.byId('demandListOverlay').hide();
                _common.handleError(message, ioArgs);
            },
            url: '/API/Demand/' + (demandKey ? demandKey : '')
        });
        return dfd;
    };

    /**
     * Tell of the specified proposal has been cached.
     *
     * @param {String} proposalKey Identifier of the proposal to load.
     * @return {Boolean} <code>true</code> if the proposal is cached, <code>false</code> otherwise.
     */
    module.isProposalCached = function(proposalKey) {
        return _proposals[proposalKey];
    };

    /**
     * Get the specified proposal from the cache.
     *
     * @param {String} proposalKey Identifier of the proposal to load.
     * @return {Proposal} Identified proposal if it exists, <code>null</code> otherwise;.
     */
    module.getCachedProposal = function(proposalKey) {
        return _proposals[proposalKey];
    };

    /**
     * Load the identified proposal by its key from the remote back-end.
     *
     * @param {String} proposalKey Identifier of the proposal to load.
     * @param {String} pointOfView (Optional) operation initiator point of view, default to SALE_ASSOCIATE.
     * @return {dojo.Deferred} Object that callers can use to attach callbacks and errbacks.
     */
    module.loadRemoteProposal = function(proposalKey, pointOfView) {
        dijit.byId('proposalFormOverlay').show();
        var dfd = dojo.xhrGet({
            content: {
                pointOfView: pointOfView || _common.POINT_OF_VIEWS.SALE_ASSOCIATE,
                related: ['Store']
            },
            handleAs: 'json',
            load: function(response, ioArgs) {
                if (response && response.success) {
                    var resource = response.resource;
                    _proposals[proposalKey] = resource;
                }
                else {
                    alert(response.message + '\nurl: '+ ioArgs.url);
                }
                dijit.byId('proposalFormOverlay').hide();
                return response;
            },
            error: function(message, ioArgs) {
                dijit.byId('proposalFormOverlay').hide();
                _common.handleError(message, ioArgs);
            },
            url: '/API/Proposal/' + proposalKey
        });
        return dfd;
    };

    /**
     * Call the back-end to create or update a Proposal with the given attribute
     *
     * @param {Object} data Set of attributes built from the <code>form</code> embedded in the dialog box.
     * @param {Number} proposalKey (Optional) proposal identifier, picked-up in the given JSON bag if missing.
     * @return {dojo.Deferred} Object that callers can use to attach callbacks and errbacks.
     */
    module.updateRemoteProposal = function(data, proposalKey, pointOfView) {
        dijit.byId('demandListOverlay').show();
        proposalKey = proposalKey || data.key;
        var dfd = (proposalKey ? dojo.xhrPut : dojo.xhrPost)({
            headers: { 'content-type': 'application/json; charset=utf-8' },
            postData: dojo.toJson(data),
            putData: dojo.toJson(data),
            handleAs: 'json',
            load: function(response, ioArgs) {
                if (response && response.success) {
                    var proposal = response.resource;
                    _proposals[proposal.key] = proposal;
                }
                else {
                    alert(response.message + '\nurl: '+ ioArgs.url);
                }
                dijit.byId('demandListOverlay').hide();
            },
            error: function(message, ioArgs) {
                dijit.byId('demandListOverlay').hide();
                _common.handleError(message, ioArgs);
            },
            url: '/API/Proposal/' + (proposalKey ? proposalKey : '')
        });
        return dfd;
    };

    module.setLocation = function(locationKey, postalCodeField, countryCodeField) {
        var location = _locations[locationKey];
        if (location) {
            postalCodeField.set('value', location.postalCode);
            countryCodeField.set('value', location.countryCode);
            return;
        }
    }

    module.getBrowserLocation = function(overlayId) {
        var eventName = 'browserLocationCodeAvailable';
        var handle = dojo.subscribe(eventName, function(postalCode, countryCode) {
            dijit.byId('demand.postalCode').set('value', postalCode);
            dijit.byId('demand.countryCode').set('value', countryCode);
            dijit.byId('demand.postalCode').focus();
            dojo.unsubscribe(handle);
        });
        _common.getBrowserLocation(eventName, overlayId);
    }

    module.showDemandLocaleMap = function() {
        var postalCode = dijit.byId('demand.postalCode').get('value');
        var countryCode = dijit.byId('demand.countryCode').get('value');
        _common.showMap(postalCode, countryCode);
    }

    module.showStoreLocaleMap = function() {
        alert('Not yet implemented!');
//        var postalCode = dijit.byId("demand.postalCode").get("value");
//        var countryCode = dijit.byId("demand.countryCode").get("value");
//        _common.showMap(postalCode, countryCode);
    }
})(); // End of the function limiting the scope of the private variables
