(function() { // To limit the scope of the private variables

    var module = dojo.provide('twetailer.Common');

    dojo.require("dojo.date.stamp");
    dojo.require('domderrien.i18n.LabelExtractor');

    /* Set of local variables */
    var _getLabel,
        _locale,
        _supportGeolocation,
        _geoCoder,
        _postalCode,
        _countryCode,
        _geoCache = {},
        _lastBrowserLocation,
        _browserLocationOverlayId,
        _getPostalCountryEventName,
        _friendRowNb = 1,
        _locations = {},
        _demands = {},
        _proposals = {},
        _lastDemand,
        _lastProposal;

    /**
     * List of possible command states (command being a Demand or a Proposal).
     */
    module.STATES = {
        OPENED: 'opened',
        INVALID: 'invalid',
        PUBLISHED: 'published',
        CONFIRMED: 'confirmed',
        CLOSED: 'closed',
        DECLINED: 'declined',
        CANCELLED: 'cancelled',
        DELETED: 'markedForDeletion'
    };

    /**
     * List of operation point of view.
     */
    module.POINT_OF_VIEWS = {
        CONSUMER: 'CONSUMER',             // twetailer.dto.Command.QueryPointOfView.CONSUMER
        SALE_ASSOCIATE: 'SALE_ASSOCIATE', // twetailer.dto.Command.QueryPointOfView.SALE_ASSOCIATE
        ANONYMOUS: 'ANONYMOUS'            // twetailer.dto.Command.QueryPointOfView.ANONYMOUS
    };

    //
    // Helpers for the Grid instances
    //

    /**
     * Initializer.
     *
     * @param {String} locale Identifier of the chosen locale.
     * @param {String} getGeoButtonId Identifier of the button allowing to query the browser location.
     * @return {Function} Shortcut on the local function getting localized labels.
     */
    module.init = function(locale, getGeoButtonId) {
        _locale = locale;

        // Get the localized resource bundle
        domderrien.i18n.LabelExtractor.init('twetailer', 'master', locale);
        domderrien.i18n.LabelExtractor.init('twetailer', 'console', locale);
        _getLabel = domderrien.i18n.LabelExtractor.getFrom;

        _supportGeoLocation = navigator.geolocation;
        var getCoordinatesButton = dijit.byId(getGeoButtonId);
        if (getCoordinatesButton) {
            getCoordinatesButton.set('disabled', !_supportGeoLocation);
        }

        return _getLabel;
    };

    /**
     * Helper to generate an ISO formatted date without the timezone.
     *
     * @param {Date} date date part to be formatted.
     * @param {Date} timee time part to be formatted.
     * @return {String} ISO representation of the given date.
     */
    module.toISOString = function(date, time) {
        // return dojo.date.stamp.toISOString(date, {}); // Contains the timezone gap
        var month = date.getMonth() + 1;
        var day = date.getDate();
        var hours = time ? time.getHours() : 0;
        var minutes = time ? time.getMinutes() : 0;
        return date.getFullYear() +
              (month < 10 ? '-0' : '-') + month +
              (day < 10 ? '-0' : '-') + day +
              (hours < 10 ? 'T0' : 'T') + hours +
              (minutes < 10 ? ':0' : ':') + minutes +
              ':00';
    };

    /**
     * Date formatter.
     *
     * @param {String} ISO representation of a Date, as generated by the back-end.
     * @return {String} Simply formatted date.
     */
    module.displayDate = function(serializedDate) {
        try {
            var dateObject = dojo.date.stamp.fromISOString(serializedDate);
            return dojo.date.locale.format(dateObject, {selector: 'date'});
        }
        catch (ex) {
            console.log("displayDate('" + serializedDate + "') -- ex: " + ex.message);
            return "<span class='invalidData' title='" + _getLabel('console', 'error_invalid_date', [serializedDate]) + "'>" + _getLabel('console', 'error_invalid_data') + '</span>';
        }
    };

    /**
     * Date & Time formatter.
     *
     * @param {String} ISO representation of a Date, as generated by the back-end.
     * @return {String} Simply formatted date.
     */
    module.displayDateTime = function(serializedDate) {
        try {
            var dateObject = dojo.date.stamp.fromISOString(serializedDate);
            return dojo.date.locale.format(dateObject, {selector: 'dateTime'});
        }
        catch (ex) {
            console.log("displayDateTime('" + serializedDate + "') -- ex: " + ex.message);
            return "<span class='invalidData' title='" + _getLabel('console', 'error_invalid_date', [serializedDate]) + "'>" + _getLabel('console', 'error_invalid_data') + '</span>';
        }
    };

    /**
     * Locale formatter with a lookup in the Location list
     *
     * @param {String[]} locationKey Identifier of the Location to represente.
     * @return {String} Composition of the postal and the country codes in a link to Google Maps.
     */
    module.displayLocale = function(locationKey) {
        if (!locationKey) {
            return '';
        }
        var location = _locations[locationKey];
        if (location) {
            return "<a href='javascript:twetailer.Common.showMap(\"" + location.postalCode + '\",\"' + location.countryCode + "\")'>" + location.postalCode + ' ' + location.countryCode + '</a>';
        }
        return "<span class='invalidData' title='" + _getLabel('console', 'error_invalid_locale') + "'>" + _getLabel('console', 'error_invalid_data') + '</span>';
    };

    /**
     * Criteria formatter.
     *
     * @param {String[]} criteria List of criteria, as generated by the back-end.
     * @return {String} Serialized criteria list.
     */
    module.displayCriteria = function(criteria) {
        if (!criteria) {
            return '';
        }
        if (dojo.isArray(criteria)) {
            return criteria.join(' ');
        }
        console.log('displayCriteria(' + criteria + ') is not an Array');
        return "<span class='invalidData' title='" + _getLabel('console', 'error_invalid_array') + "'>" + _getLabel('console', 'error_invalid_data') + '</span>';
    };

    /**
     * Hash tag list formatter.
     *
     * @param {String[]} hashTags List of hash tags, as generated by the back-end.
     * @return {String} Serialized hash tag list.
     */
    module.displayHashTags = function(hashTags) {
        if (!hashTags) {
            return '';
        }
        if (dojo.isArray(hashTags)) {
            if (hashTags.length == 0) {
                return '';
            }
            return '#' + hashTags.join(' #');
        }
        console.log('displayHashTags(' + hashTags + ') is not an Array');
        return "<span class='invalidData' title='" + _getLabel('console', 'error_invalid_array') + "'>" + _getLabel('console', 'error_invalid_data') + '</span>';
    };

    var _ccTwitterDecoration = ["<a href='http://twitter.com/", null, "' target='twTwitter'>", null, '</a>'];
    var _ccEmailDecoration = ["<a href='mailto:", null, "'>", null, '</a>'];

    /**
     * CC formatter.
     *
     * @param {String[]} ccList List of CC-ed users' identifier, as generated by the back-end.
     * @return {String} Serialized identifier list.
     */
    module.displayCCList = function(ccList) {
        if (!ccList) {
            return '';
        }
        if (dojo.isArray(ccList)) {
            var value = [], cc, ccLinked;
            var limit = ccList.length;
            for (var idx = 0; idx < limit; idx++) {
                cc = ccList[idx];
                ccLinked = cc;
                var decorationRef = _ccEmailDecoration;
                if (cc.charAt(0) == '@') {
                    ccLinked = cc.substring(1);
                    decorationRef = _ccTwitterDecoration;
                }
                else if (cc.indexOf('@') == -1) {
                    decorationRef = _ccTwitterDecoration;
                }
                decorationRef[1] = ccLinked;
                decorationRef[3] = cc;
                value.push(decorationRef.join(''));
            }
            return value.join(', ');
        }
        console.log('displayCC(' + ccList + ') is not an Array');
        return "<span class='invalidData' title='" + _getLabel('console', 'error_invalid_array') + "'>" + _getLabel('console', 'error_invalid_data') + '</span>';
    };

    /**
     * Locale formatter with a lookup in the Location list
     *
     * @param {String[]} locationKey Identifier of the Location to represente.
     * @return {String} Composition of the postal and the country codes in a link to Google Maps.
     */
    module.displayMetadata = function(metadata) {
        if (!metadata) {
            return '';
        }
        try {
            return dojo.toJson(dojo.fromJson(metadata), false);
            // return dojo.toJson(dojo.fromJson(metadata), true);
        }
        catch(ex) {
            return "<span class='invalidData' title='" + _getLabel('console', 'error_invalid_metadata') + "'>" + _getLabel('console', 'error_invalid_data') + '</span>';
        }
    };

    /**
     * Formatter for the list of attached proposal keys.
     *
     * @param {Number[]} proposalKeys List of proposal keys.
     * @param {Number} rowIndex index of the data in the grid, used by the trigger launching the Proposal properties pane.
     * @param {Array} decoration Link definition wrapping a proposal key with:
     *                   ${0}: place holder for the proposalKey
     *                   ${1}: place holder for the rowIndex.
     * @return {String} Formatter list of one link per proposal key, a link opening a dialog with the proposal detail.
     */
    module.displayProposalKeys = function(proposalKeys, rowIndex, decoration) {
        if (!proposalKeys) {
            return '';
        }
        if (dojo.isArray(proposalKeys)) {
            var value = [], pK;
            var limit = proposalKeys.length;
            for (var idx = 0; idx < limit; idx++) {
                pK = proposalKeys[idx];
                value.push(dojo.string.substitute(decoration || '${0}', [pK, rowIndex]));
            }
            return value.join(' ');
        }
        return "<span class='invalidData' title='" + _getLabel('console', 'error_invalid_array') + "'>" + _getLabel('console', 'error_invalid_data') + '</span>';
    };

    /**
     * Helper verifying the HTTP status code and acting accordingly.
     * Worse case, the given message is displayed with the request URL.
     *
     * @param {String} message information generated by the system.
     * @param {Object} ioArgs Parameters of the XHR call.
     */
    module.handleError = function(message, ioArgs) {
        if (ioArgs.xhr.status == 403) { // 403 == Forbidden
            _getLabel('console', 'error_user_access_forbidden');
            window.location = './';
            return;
        }
        if (ioArgs.xhr.status == 401) { // 401 == Unauthorized
            alert(_getLabel('console', 'error_client_not_authenticated'));
            window.location = '/logout?fromPageURL=' + window.location;
            return;
        }
        if (ioArgs.xhr.status == 500) { // 500 == Server error
            alert(_getLabel('console', 'error_client_side_communication_failed'));
            return;
        }
        alert(message + '\nurl: ' + ioArgs.url);
    };

    var _previouslySelectedCountryCode = null;

    //
    // Helpers managing the global caches
    //

    /**
     * Get the specified demand from the cache.
     *
     * @param {String} demandKey Identifier of the demand to load.
     * @return {Demand} Identified demand if it exists, <code>null</code> otherwise;.
     */
    module.getCachedDemand = function(demandKey) {
        return _demands[demandKey];
    };

    /**
     * Return the last modified demand.
     *
     * @return {Demand} Identified demand if it exists, <code>null</code> otherwise.
     */
    module.getLastDemand = function(demandKey) {
        return _lastDemand;
    };

    /**
     * Get the specified proposal from the cache.
     *
     * @param {String} proposalKey Identifier of the proposal to load.
     * @return {Proposal} Identified proposal if it exists, <code>null</code> otherwise;.
     */
    module.getCachedProposal = function(proposalKey) {
        return _proposals[proposalKey];
    };

    /**
     * Return the last modified proposal.
     *
     * @return {Proposal} Identified proposal if it exists, <code>null</code> otherwise.
     */
    module.getLastProposal = function(proposalKey) {
        return _lastProposal;
    };

    //
    // Helpers loading instances from the server and fetching the corresponding grids
    //

    /**
     * Load the demands modified after the given date from the back-end.
     *
     * @param {Date} lastModificationDate (Optional) Date to considered before returning the demands (ISO formatted).
     * @param {String} overlayId (Optional) Identifier of the overlay to display during the transaction
     * @param {String} pointOfView (Optional) operation initiator point of view, default to CONSUMER server-side.
     * @param {String} hashTag (Optional) hash tag used to filter out the demands.
     * @return {dojo.Deferred} Object that callers can use to attach callbacks and errbacks.
     */
    module.loadRemoteDemands = function(lastModificationISODate, overlayId, pointOfView, hashTag) {
        if (overlayId) {
            dijit.byId(overlayId).show();
        }
        var data = {
            pointOfView: pointOfView || module.POINT_OF_VIEWS.CONSUMER,
            lastModificationDate: lastModificationISODate,
            related: ['Location']
        };
        if (hashTag) {
            data.hashTags = [hashTag];
        }
        var dfd = dojo.xhrGet({
            content: data,
            handleAs: 'json',
            load: function(response, ioArgs) {
                if (response && response.success) {
                    // Deferred callback will process the list
                    _lastDemand = null;
                    var resources = response.resources;
                    var resourceNb = resources ? resources.length : 0;
                    if (0 < resourceNb) {
                        _lastDemand = resources[0];
                        for (var i = 0; i < resourceNb; ++i) {
                            // Add the updated demand into the cache
                            var resource = resources[i];
                            _demands[resource.key] = resource;
                            // Remove the associated and possibly updated proposals from the cache
                            var proposalKeys = resource.proposalKeys;
                            var proposalKeyNb = proposalKeys? proposalKeys.length : 0;
                            for (var j = 0; j < proposalKeyNb; j++) {
                                delete _proposals[proposalKeys[j]];
                            }
                        }
                    }
                    if (0 < resourceNb) {
                        // Add the locations to the cache
                        var resource = resources[0];
                        var locations = resource.related ? resource.related.Location : null;
                        var locationNb = locations ? locations.length : 0;
                        for (var k = 0; k < locationNb; k++) {
                            var location = locations[k];
                            _locations[location.key] = location;
                        }
                        delete resource.related;
                    }
                }
                else {
                    alert(response.message + '\nurl: '+ ioArgs.url);
                }
                if (overlayId) {
                    dijit.byId(overlayId).hide();
                }
                return response;
            },
            error: function(message, ioArgs) {
                if (overlayId) {
                    dijit.byId(overlayId).hide();
                }
                module.handleError(message, ioArgs);
            },
            preventCache: true,
            url: '/API/Demand/'
        });
        return dfd;
    };

    /**
     * Callback processing a list of demands that should replace the current grid content.
     *
     * @param {Demand[]} List of demands to insert into the grid.
     * @param {DataGrid} Reference on the grid to fetch.
     */
    module.processDemandList = function(resources, grid) {
        // Prepare the data store
        var demandStore = new dojo.data.ItemFileWriteStore({
            data: { identifier: 'key', items: resources }
        });
        // Fetch the grid with the data
        demandStore.fetch({
            query: {},
            onComplete: function(items, request) {
                if (grid.selection) {
                    grid.selection.clear();
                }
                grid.setStore(demandStore);
            },
            error: function(message, ioArgs) {
                module.handleError(message, ioArgs);
            },
            sort: [{attribute: 'modificationDate', descending: true}]
        });
    };

    /**
     * Call the back-end to create or update a Demand with the given attribute.
     *
     * @param {Object} data Set of attributes built from the <code>form</code> embedded in the dialog box.
     * @param {Number} demandKey (Optional) demand identifier, picked-up in the given JSON bag if missing.
     * @param {String} overlayId (Optional) Identifier of the overlay to display during the transaction
     * @return {dojo.Deferred} Object that callers can use to attach callbacks and errbacks.
     */
    module.updateRemoteDemand = function(data, demandKey, overlayId) {
        if (overlayId) {
            dijit.byId(overlayId).show();
        }
        demandKey = demandKey || data.key;
        var dfd = (demandKey ? dojo.xhrPut : dojo.xhrPost)({
            headers: { 'content-type': 'application/json; charset=utf-8' },
            postData: dojo.toJson(data),
            putData: dojo.toJson(data),
            handleAs: 'json',
            load: function(response, ioArgs) {
                if (response && response.success) {
                    var demand = response.resource;
                    _demands[demand.key] = demand;
                }
                else {
                    alert(response.message + '\nurl: '+ ioArgs.url);
                }
                dijit.byId('demandListOverlay').hide();
            },
            error: function(message, ioArgs) {
                if (overlayId) {
                    dijit.byId(overlayId).hide();
                }
                module.handleError(message, ioArgs);
            },
            url: '/API/Demand/' + (demandKey ? demandKey : '')
        });
        return dfd;
    };

    /**
     * Load the identified proposal by its key from the remote back-end.
     *
     * @param {String} proposalKey Identifier of the proposal to load.
     * @param {String} overlayId (Optional) Identifier of the overlay to display during the transaction
     * @param {String} pointOfView (Optional) operation initiator point of view, default to SALE_ASSOCIATE.
     * @return {dojo.Deferred} Object that callers can use to attach callbacks and errbacks.
     */
    module.loadRemoteProposal = function(proposalKey, overlayId, pointOfView) {
        if (overlayId) {
            dijit.byId(overlayId).show();
        }
        var dfd = dojo.xhrGet({
            content: {
                pointOfView: pointOfView || module.POINT_OF_VIEWS.SALE_ASSOCIATE,
                related: ['Store']
            },
            handleAs: 'json',
            load: function(response, ioArgs) {
                if (response && response.success) {
                    var resource = response.resource;
                    _proposals[proposalKey] = resource;
                }
                else {
                    alert(response.message + '\nurl: '+ ioArgs.url);
                }
                if (overlayId) {
                    dijit.byId(overlayId).hide();
                }
                return response;
            },
            error: function(message, ioArgs) {
                if (overlayId) {
                    dijit.byId(overlayId).hide();
                }
                module.handleError(message, ioArgs);
            },
            url: '/API/Proposal/' + proposalKey
        });
        return dfd;
    };

    /**
     * Call the back-end to create or update a Proposal with the given attribute.
     *
     * @param {Object} data Set of attributes built from the <code>form</code> embedded in the dialog box.
     * @param {Number} proposalKey (Optional) proposal identifier, picked-up in the given JSON bag if missing.
     * @param {String} overlayId (Optional) Identifier of the overlay to display during the transaction
     * @return {dojo.Deferred} Object that callers can use to attach callbacks and errbacks.
     */
    module.updateRemoteProposal = function(data, proposalKey, pointOfView, overlayId) {
        if (overlayId) {
            dijit.byId(overlayId).show();
        }
        proposalKey = proposalKey || data.key;
        var dfd = (proposalKey ? dojo.xhrPut : dojo.xhrPost)({
            headers: { 'content-type': 'application/json; charset=utf-8' },
            postData: dojo.toJson(data),
            putData: dojo.toJson(data),
            handleAs: 'json',
            load: function(response, ioArgs) {
                if (response && response.success) {
                    var proposal = response.resource;
                    _proposals[proposal.key] = proposal;
                }
                else {
                    alert(response.message + '\nurl: '+ ioArgs.url);
                }
                if (overlayId) {
                    dijit.byId(overlayId).show();
                }
            },
            error: function(message, ioArgs) {
                if (overlayId) {
                    dijit.byId(overlayId).hide();
                }
                module.handleError(message, ioArgs);
            },
            url: '/API/Proposal/' + (proposalKey ? proposalKey : '')
        });
        return dfd;
    };

    //
    // Helpers related to the geo-localisation
    //

    /**
     * Helper Fetching the identified &lt;input.&gt; fields with the information from the identified location
     *
     * @param {Number} locationKey Identifier of the <code>twetailer.dto.Location</code> instance
     * @param {Object} postalCodeField <code>dijit.form.TextBox</code> instance hosting the postal code
     * @param {Object} countryCodeField <code>dijit.form.TextBox</code> instance hosting the country code
     */
    module.setLocation = function(locationKey, postalCodeField, countryCodeField) {
        var location = _locations[locationKey];
        if (location) {
            postalCodeField.set('value', location.postalCode);
            countryCodeField.set('value', location.countryCode);
            return;
        }
    }

    /**
     * Helper modifying on the fly the constraints for the postal code field.
     *
     * @param {String} countryCode New country code.
     * @param {String} postalCodeFieldId Identifier of the postal code field.
     */
    module.updatePostalCodeFieldConstraints = function(countryCode, postalCodeFieldId) {
        if (_previouslySelectedCountryCode != countryCode) {
            var pcField = dijit.byId(postalCodeFieldId);
            if (pcField) {
                pcField.set('regExp', _getLabel('console', 'location_postalCode_regExp_' + countryCode));
                pcField.set('placeHolder', _getLabel('console', 'location_postalCode_placeHolder_' + countryCode));
                pcField.set('invalidMessage', _getLabel('console', 'location_postalCode_invalid_' + countryCode));
                pcField.focus();
            }
            _previouslySelectedCountryCode = countryCode;
        }
    };

    /**
     * Invoke a third-party service (Google Maps) to get the geographical coordinate of the given location
     * and render the corresponding map in a dialog box with id "locationMapDialog".
     *
     * @param {String} postalCode postal code in "A1A1A1" for Canada, and "12345" for USA.
     * @param {String} countryCode ISO of the country.
     */
    module.showMap = function(postalCode, countryCode) {
        _postalCode = postalCode;
        _countryCode = countryCode;

        var cachedValue = _geoCache[_postalCode + '-' + countryCode];
        if (cachedValue) {
            _placeMap(cachedValue);
            return;
        }

        var countryShortLabel = _countryCode == 'CA' ? 'Cananda' : 'USA';
        var geoCoderParameters = {
            language: _locale,
            address: _postalCode + ',' + countryShortLabel,
            region: countryCode
        };
        if (!_geoCoder) {
            _geoCoder = new google.maps.Geocoder();
        }
        _geoCoder.geocode(geoCoderParameters, _getGeoCoordinatesCallback);
    };

    /**
     * Callback dispatching the resolved {postal code, country code} or displaying an error message.
     *
     * @param {Array} results Array of possible locations matching the given {postal code, country code}.
     * @param {Number} status Status of the lookup operation.
     *
     * @see Common#_placeMap(Object)
     */
    var _getGeoCoordinatesCallback = function(results, status) {
        if (google.maps.GeocoderStatus.OK == status) {
            var location = results[0].geometry.location;
            _geoCache[_postalCode + '-' + _countryCode] = location;
            _placeMap(location);
        }
        else {
            alert(_getLabel('console', 'shared_invalid_locale_message', [_postalCode, _countryCode]));
        }
    };

    /**
     * Helper displaying a map (from Google) centered on the specified location.
     *
     * @param {Object} location set of gographical coordinates.
     *
     * @see Common#_getGeoCoordinatesCallback(Array, Number)
     */
    var _placeMap = function(location) {
        // Dialog should be displayed first for the map to appear correctly!
        dijit.byId('locationMapDialog').show();

        // Creating a map
        var map = new google.maps.Map(
            dojo.byId('mapPlaceHolder'), {
                center: location,
                language: _locale,
                mapTypeId: google.maps.MapTypeId.ROADMAP,
                zoom: 10
            }
        );

        // Image shadow made with: http://www.cycloloco.com/shadowmaker/shadowmaker.htm
        // Google Maps API for overlays: http://code.google.com/apis/maps/documentation/v3/overlays.html

        var image = new google.maps.MarkerImage(
            '/images/logo/gmaps-marker.png',
            new google.maps.Size(38, 73),
            new google.maps.Point(0, 0),
            new google.maps.Point(28, 70)
        );
        var shadow = new google.maps.MarkerImage(
            '/images/logo/gmaps-marker-shadow.png',
            new google.maps.Size(75, 73),
            new google.maps.Point(0, 0),
            new google.maps.Point(20, 70)
        );
        // Creating a marker and positioning it on the map
        var marker = new google.maps.Marker({
            clickable: false,
            icon: image,
            shadow: shadow,
            map: map,
            position: location,
            title: _postalCode + ' ' + _countryCode
        });
    };

    /**
     * Helper displaying the specified overlay and getting the {postal code, country code}
     * from browser geo-coordinates asynchronously.
     *
     * @param {String} postalCodeId Identifier of the field to receive the postal code.
     * @param {String} countryCodeId Identifier of the field to receive the country code.
     * @param {String} overlayId (Optional) Identifier of the overlay to show during the request.
     */
    module.fetchBrowserLocation = function(postalCodeId, countryCodeId, overlayId) {
        var eventName = "browserLocationCodeAvailable";
        var handle = dojo.subscribe(eventName, function(postalCode, countryCode) {
            dijit.byId(postalCodeId).set("value", postalCode);
            dijit.byId(countryCodeId).set("value", countryCode);
            dijit.byId(postalCodeId).focus();
            dojo.unsubscribe(handle);
        })
        module.getBrowserLocation(eventName, overlayId);
    }

    /**
     * Utility method getting the geo-coordinates from the browser and then the postal and country code
     * for the corresponding geo-position in order to notify the listeners waiting on the specified
     * event the corresponding codes.
     *
     * @param {String} eventName Name of the notification.
     * @param {String} overlayId (Optional) Identifier of the overlay to show while the asynchronous operation is in progress.
     *
     * @see twetailer.Common#_successCallbackBrowserLocation(Array, Number)
     * @see twetailer.Common#_errorCallbackBrowserLocation(Object)
     */
    module.getBrowserLocation = function(eventName, overlayId) {
        _browserLocationOverlayId = overlayId;
        _getPostalCountryEventName = eventName;

        if (overlayId) {
            dijit.byId(overlayId).show();
        }

        /* // Will trigger one immediate lookup in the browser cache, and if not cached the error handler will trigger a remote call => step not necessary
        navigator.geolocation.getCurrentPosition(
            _successCallbackBrowserLocation,
            _errorCallbackBrowserLocation,
            {
                maximumAge: Infinity,
                timeout: 0
            }
        );
        */
        navigator.geolocation.getCurrentPosition(_successCallbackBrowserLocation, _errorCallbackBrowserLocation);
    };

    /**
     * Helper calling a third party service (Google) to get the postal and country codes for a
     * the geo-position reported by the browser (HTML5 compliant browser).
     *
     * @param {Object} position Set of coordinates reported by the browser.
     *
     * @see twetailer.Common#_getPostalCountryCodesCallback(Array, Number)
     */
    var _successCallbackBrowserLocation = function(position) {
        var coords = position.coords; // coords: {latitude, longitude, altitude, accuracy, altitudeAccuracy, heading, speed}
        if (_lastBrowserLocation && _lastBrowserLocation.latitude == coords.latitude && _lastBrowserLocation.longitude == coords.longitude) {
            _notifyBrowserLocation(_lastBrowserLocation.postalCode, _lastBrowserLocation.countryCode);
        }
        else {
            var geoCoderParameters = {
                language: _locale,
                latLng: new google.maps.LatLng(coords.latitude, coords.longitude)
            };
            if (!_geoCoder) {
                _geoCoder = new google.maps.Geocoder();
            }
            _lastBrowserLocation = {
                latitude: coords.latitude,
                longitude: coords.longitude
            };
            _geoCoder.geocode(geoCoderParameters, _getPostalCountryCodesCallback);
        }
    };

    /**
     * Helper reporting missing cached value and invoking a third party service or reporting a raw error.
     *
     * @param {Object} error Error record.
     */
    var _errorCallbackBrowserLocation = function(error) {
        // TODO: put the messages in the console.tmx
        switch (error.code) {
            case 3: // error.TIMEOUT:
                /* // Will trigger a remote call when the immediate browser cache lookup failed => not necessary
                navigator.geolocation.getCurrentPosition(_successCallbackBrowserLocation, _errorCallbackBrowserLocation);
                break;
                */
            case 2: // error.POSITION_UNAVAILABLE:
            case 1: // error.PERMISSION_DENIED:
            default: // error.UNKNOWN_ERROR == 0
                alert(_getLabel('console', 'shared_cannot_get_geocoordinates_message'));
                _notifyBrowserLocation();
        }
    };

    /**
     * Helper parsing the returned address list to extract a postal code and a country code.
     *
     * @param {Array} results Array of possible locations matching the given {postal code, country code}.
     * @param {Number} status Status of the lookup operation.
     *
     * @see twetailer.Common#_getGeoCoordinatesCallback(Array, Number)
     */
    var _getPostalCountryCodesCallback = function(results, status) {
        if (google.maps.GeocoderStatus.OK == status) {
            var pC = null, cC = null, idx = results.length, jdx, COUNTRY_TAG = 'country', POSTAL_CODE_TAG = 'postal_code';
            while (0 < idx) {
                idx--;
                var parts = results[idx].address_components;
                jdx = parts.length;
                while (0 < jdx) {
                    jdx--;
                    var part = parts[jdx];
                    if (!cC && part.types[0] == COUNTRY_TAG) {
                        cC = part.short_name;
                    }
                    else if (!pC && part.types[0] == POSTAL_CODE_TAG && 3 < part.short_name.length) {
                        pC = part.short_name;
                    }
                    if (pC && cC) { break; }
                }
                if (pC && cC) { break; }
            }
            if (pC && cC) {
                var location = results[0].geometry.location;
                _lastBrowserLocation.postalCode = pC;
                _lastBrowserLocation.countryCode = cC;
               _notifyBrowserLocation(pC, cC);
               return;
            }
            alert(_getLabel('console', 'shared_cannot_resolve_geocoordinates_message'));
            _lastBrowserLocation = null;
            _notifyBrowserLocation();
            return;
        }
        alert(_getLabel('console', 'shared_invalid_locale_message', [_postalCode, _countryCode]));
        _lastBrowserLocation = null;
        _notifyBrowserLocation();
    };

    /**
     * Helper notifying listeners about the set of codes for the browser location.
     *
     * @param {Object} postalCode Information to be broadcasted with the notification.
     * @param {Object} countryCode Information to be broadcasted with the notification.
     */
    var _notifyBrowserLocation = function(postalCode, countryCode) {
        dojo.publish(_getPostalCountryEventName, [postalCode, countryCode]);

        if (_browserLocationOverlayId) {
            dijit.byId(_browserLocationOverlayId).hide();
        }
    };

    //
    // Business logic controlling the [+] / [-] buttons attached to the &lt;input/&gt; fields hosting the CC'ed user information
    //

    /**
     * Handles a click on a [+] or [-] button placed near an &lt;input/&gt; which is going to receive
     * the coordinate of someone to be cc'ed for the corresponding demand.
     *
     * @param {Number} rowIdx index of the &lt;input/&gt; field (starts at 1).
     * @param {String} fieldLabel label of the field to be inserted in a cell before the &lt;input/&gt; field.
     *
     * The HTML code should define the following tags. Note that the ellipsis (...)
     * replace labels or values that depend on the final implementation details.<pre>
     *   &lt;table style="..."&gt;
     *       &lt;tbody id="friendList"&gt;         // All new rows are appended as child to this element
     *           &lt;tr&gt;
     *               &lt;td&gt;                    // Optional raw with the label to be receive the &lt;input/&gt; label
     *                   &lt;label for="email1"&gt;
     *                       ...
     *                   &lt;/label&gt;
     *               &lt;/td&gt;
     *               &lt;td&gt;
     *                   &lt;input
     *                       dojoType="dijit.form.ValidationTextBox"
     *                       id="email1"           // This identifier allows to use this widget as the master copy to others
     *                       invalidMessage="..."  // Value copied in cloned rows
     *                       name="email1"         // This identifier is used when the form is submitted
     *                       placeHolder="..."     // Value copied in cloned rows
     *                       regExp="..."          // Value copied in cloned rows
     *                       required="false"
     *                       style="width:100%;"
     *                       trim="true"
     *                       type="text"
     *                 /&gt;
     *               &lt;/td&gt;
     *               &lt;td style="width:20px;padding-right:0px !important;"&gt;
     *                   &lt;button
     *                       dojoType="dijit.form.Button"
     *                       iconClass="silkIcon silkIconAdd"
     *                       id="friendButton1"    // This value is used to retrieve the button and to change its meaning if it's the last visible one
     *                       onclick="twetailer.Common.manageFriendRow(1);"
     *                       showLabel="false"
     *                       title="..."           // Value copied in cloned rows
     *                   &gt;&lt;/button&gt;
     *               &lt;/td&gt;
     *           &lt;/tr&gt;
     *       &lt;/tbody&gt;
     *   &lt;/table&gt;</pre>
     *
     */
    module.manageFriendRow = function(rowIdx, fieldLabel) {
        if (_friendRowNb == 1 && !dijit.byId('email1')) {
            alert('The HTML is misconfigured! Please check the documentation to verify the requirements.');
            return;
        }
        if (rowIdx == _friendRowNb) {
            // Add a row with a new <input/> field
            var button = dijit.byId('friendButton' + rowIdx);
            button.set('iconClass', 'silkIcon silkIconDelete');
            button.set('title', _getLabel('console', 'remove_ccInfo_button'));
            _friendRowNb++;
            var fIdx = _friendRowNb;
            var firstField = dijit.byId('email1');
            var row = dojo.create('tr', { id: 'friendRow' + fIdx }, dojo.byId('friendList'));
            if (fieldLabel) {
                dojo.create('label', { forAttr: 'email' + fIdx, innerHTML: fieldLabel }, dojo.create('td', null, row));
            }
            dojo.create('td', null, row).appendChild(
                new dijit.form.ValidationTextBox({
                    id: 'email' + fIdx,
                    invalidMessage: firstField.get('invalidMessage'),
                    name: 'email' + fIdx,
                    placeHolder: firstField.get('placeHolder'),
                    required: false,
                    style: 'width:100%',
                    trim: true }).domNode
            );
            dojo.create('td', { style: 'width:20px;padding-right:0px !important;' }, row).appendChild(
                new dijit.form.Button({
                    iconClass: 'silkIcon silkIconAdd',
                    id: 'friendButton' + fIdx,
                    onClick: function() { module.manageFriendRow(fIdx, fieldLabel); },
                    showLabel: false,
                    title: firstField.get('title') }).domNode
            );
            dijit.byId('email' + fIdx).set('regExp', dijit.byId('email1').get('regExp')); // Work-around: otherwise, it seems the regExp value is misinterpreted!
        }
        else {
            // Remove the identified row
            var fIdx = _friendRowNb;
            for (var i = rowIdx; i < fIdx; i++) {
                dijit.byId('email' + i).set('value', dijit.byId('email' + (i + 1)).get('value'));
            }
            dijit.byId('email' + fIdx).destroy();
            dijit.byId('friendButton' + fIdx).destroy();
            dojo.destroy('friendRow' + fIdx);
            _friendRowNb--;
            fIdx--;
            var button = dijit.byId('friendButton' + fIdx);
            button.set('iconClass', 'silkIcon silkIconAdd');
            button.set('title', _getLabel('console', 'add_ccInfo_button'));
        }
    };

    /**
     * Return the Dijit field for the identified CC'ed friend field.
     * If the field does not yet exist, it will be created by simulating
     * user action on the [+] button up to have the corresponding field.
     *
     * @param {Number} rowIdx index of the &lt;input/&gt; field (starts at 1).
     * @param {String} fieldLabel label of the field to be inserted in a cell before the &lt;input/&gt; field.
     * @return {Object} Dijit field instance.
     *
     * @see twetailer.Console#manageFriendRow(Number, String)
     */
    module.getFriendInputField = function(rowIdx, fieldLabel) {
        var field = dijit.byId('email' + rowIdx);
        if (!field) {
            var i = _friendRowNb, limit = rowIdx;
            while (i < limit) {
                module.manageFriendRow(i);
                i++;
            }
            field = dijit.byId('email' + rowIdx);
        }
        return field;
    };

    /**
     * Scan the friend fields to stack their values in an array.
     *
     * @return {Array} Documented friend coordinates.
     *
     * @see twetailer.Console#manageFriendRow(Number, String)
     */
    module.getFriendCoordinates = function() {
        var coordinates = [], idx = 0;
        while (idx < _friendRowNb) {
            idx++; // Increment now because the field index starts at 1
            var field = dijit.byId('email' + idx);
            if (field) {
                var coordinate = field.get('value');
                if (0 < coordinate.length) {
                    coordinates.push(coordinate);
                }
            }
        }
        return coordinates;
    };
})(); // End of the function limiting the scope of the private variables
